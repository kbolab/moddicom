% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Prepare_for_Keras.R
\name{Setup_For_Keras}
\alias{Setup_For_Keras}
\title{Setup geoLet derived objects for deep learning analysis}
\usage{
Setup_For_Keras(path, outcome = NULL, ratio = 2/3, ROIname,
  ROINameNorm = NULL, TrainTest = TRUE, per_patient_sampling = TRUE,
  New_Pixel_Spacing = c(), ROIBitMask = TRUE, TargetSize = "auto",
  VirtualBiopsy = FALSE, VirtualBiopsyRay = c(10, 10),
  VirtualBiopsyMaxNum = 25, backgroud = c("zero", "min", "mean",
  "runif", "rnorm"), bckwidth = 0.5, threshold_filter = 150,
  ROImap = NULL)
}
\arguments{
\item{path}{The \code{path} of cases structured as \pkg{moddicom} usually requires (one subfolder with a DICOM study containing images and a RT structure DICOM file)}

\item{outcome}{A \code{data.frame} containing in one column the same IDs of patients listed in \code{path}, usually corresponding to the folder names, and a column with the given outcome}

\item{ratio}{a number between 0 and 1 giving the ratio between training set and verification set (default 2/3)}

\item{ROIname}{a \code{character} vector containing the ROI(s) name(s) used for extracting images from studies}

\item{ROINameNorm}{a \code{character} vector containing the ROI(s) name(s) used for used for normalizing the values, if \code{NULL} no normalization is applied}

\item{TrainTest}{\code{logical} value (default is \code{TRUE}) that gives the outcome already splitted for \emph{training} and \emph{test}.}

\item{per_patient_sampling}{a \code{logical} value (default is \code{TRUE}) that sets the sampling for training and testing set according the patients IDs. If \code{FALSE} the sampling is obtained by images slices.}

\item{New_Pixel_Spacing}{a \code{numeric} vector, length must be 2 values, that sets the new pixel spacing for all the images in order to homogenize the spatial resolution among all patients.}

\item{ROIBitMask}{a \code{logical} value, default \code{TRUE}, return only the voxels within the ROI, if \code{FALSE} returns the whole VoxelCube.}

\item{TargetSize}{default value is \code{'auto'} that calculates the size in rows and columns of final array as mean of the single VoxelCubes sizes, otherwise user can set a numerical vector of length = 2, that sets number of rows and columns manually.}

\item{VirtualBiopsy}{\code{logical} value, default is \code{FALSE}. If \code{TRUE} returns for each patient returns a number maximum number of \code{VirtualBiopsyMaxNum} of small sampling images with size \code{VirtualBiopsyRay * 2 + 1}.}

\item{VirtualBiopsyRay}{a \code{numeric} vector of length 2, giving the width os extension of \emph{Virtual Biopsy} around the centroid. Final dimension of biopsy is \code{VirtualBiopsyRay * 2 + 1}.}

\item{VirtualBiopsyMaxNum}{a \code{integer} value setting the maqximum number of \emph{Virtual Biopsies} to be sampled.}

\item{backgroud}{the value of the pixel surrounding the ROI in the background: \code{'zero'} is 0; \code{'min'} is the minimum value in the ROI; \code{'mean'} is the mean value in the ROI; \code{'runif'} is a random uniform distribution between \code{min} and \code{max} values in the ROI; \code{'rnorm'} is a random normal distrbution with \code{mean} is the mean value of ROI, \code{sd} is the standard distribution of ROI values.}

\item{bckwidth}{a \code{numeric} value between 0 and 1: the width in the range of ROI values for \code{runif} background option or the multiplier of \code{sd} for \code{rnorm} background option.}

\item{threshold_filter}{The threshold number of pixels per slice \code{NA} below which images are deleted. Default is 150 pixels.}

\item{ROImap}{If available, the result of a \link{map.ROI} function, as an object of class ROImap given by \pkg{moddicom} package.}
}
\value{
\itemize{
\item{\code{ROIList}}{: The list of ROIs as achieved by \pkg{moddicom} \code{geoLet$getROIVoxels( )} function.}
\item{\code{cases_data.frame}}{: A \code{data.frame} containing the patients IDs (\code{pt_name}), each \code{ROI_name} mapped in each patient and the \code{pt_outcome} that reports the patient outcome.}
\item{\code{images_array}}{: The final \code{array} of selected images structured  \link{keras} requires.}
\item{\code{keras_outcome}}{: A \code{numeric} vector as required by \link{keras} for the classification of outcome}
\item{\code{df_outcome}}{: A \code{data.frame} containing the labels of the outcome as provided by user and the corresponding labels (numeric values) used for modeling in \link{keras}.}
\item{\code{cases_data.frame}}{: A \code{data.frame} containing the patients IDs (\code{pt_name}), each \code{ROI_name} mapped in each patient and the \code{pt_outcome} that reports the patient outcome.}
\item{\code{images_array_train}}{: The final \code{array} of selected images structured as \link{keras} requires. This is the \emph{training} dataset. Available if \code{TrainTest=TRUE}.}
\item{\code{images_array_test}}{: The final \code{array} of selected images structured as \link{keras} requires. This is the \emph{test} dataset. Available if \code{TrainTest=TRUE}.}
\item{\code{keras_outcome_train}}{: A \code{numeric} vector as required by \link{keras} for the classification of outcome. This is the outcome for the \emph{training} dataset. Available if \code{TrainTest=TRUE}.}
\item{\code{keras_outcome_test}}{: A \code{numeric} vector as required by \link{keras} for the classification of outcome. This is the outcome for the \emph{test} dataset. Available if \code{TrainTest=TRUE}.}
\item{\code{df_outcome}}{: A \code{data.frame} containing the labels of the outcome as provided by user and the corresponding labels (numeric values) used for modeling in \link{keras}.}
\item{\code{total_data.frame_train}}{: The \code{data.frame} with all cases and slices corresponding to the images in the \code{images_array_train} array. Available if \code{TrainTest=TRUE}.}
\item{\code{total_data.frame_test}}{: The \code{data.frame} with all cases and slices corresponding to the images in the \code{images_array_test} array. Available if \code{TrainTest=TRUE}.}
}
}
\description{
Provide the output needed for starting a deep learning model using \code{\link{keras}}:
}
